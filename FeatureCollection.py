from logging import warning
from BasicClasses import CIndel, Read


class FeatureCollection:
    """Class for feature collection."""

    __insertsize = 0
    __readlength = 0
    __stdvar = 0
    __threshold = 0
    __vcindel = []
    __vread = []

    def __init__(self, vcindel):
        """Initialize an instance.
        :param vcindel: A list which contains complex indels.
        """
        for cindel in vcindel:
            self.__vcindel.append(CIndel(cindel[0], cindel[1], cindel[2]))

    def setparams(self, sampath, insertsize, stdvar, readlength):
        """Set necessary parameters and call addReads function after setting parameters.
        :param sampath: A string indicates the path to sam file (Generated by BWA software).
        :param insertsize: An integer indicates the mean distance between a pair of reads.
        :param stdvar: An integer indicates the standard variation of __insertsize.
        :param readlength: An integer indicates the fixed length of a read.
        :return: None
        """
        self.__insertsize = insertsize
        self.__readlength = readlength
        self.__stdvar = stdvar
        self.__threshold = self.__insertsize + 3 * self.__stdvar
        self.addreads(sampath)

    def addreads(self, sampath):
        """Load reads from sam file and store them.
        :param sampath: A string indicates the path to sam file (Generated by BWA software).
        :return: None.
        """
        with open(sampath, 'rt') as f:
            lines = f.read().split('\n')[2:]
            index = 0
            try:
                while index + 1 < len(lines):
                    line1, line2 = lines[index].split(), lines[index + 1].split()
                    mpr1 = Read(int(line1[3]), int(line1[4]), int(line1[7]))
                    mpr2 = Read(int(line2[3]), int(line2[4]), int(line2[7]))

                    if mpr1.pos == mpr2.pnext and mpr1.pnext == mpr2.pos:
                        mpr1.setmate(mpr2)
                        mpr2.setmate(mpr1)
                        self.__vread.append(mpr1)
                        self.__vread.append(mpr2)
                        index += 2
                    else:
                        index += 1
            except Exception as e:
                warning("File reader misread!", e)

    def collectfeature(self):
        """Collect feature for each complex indel.
        :return: A list which contains the label and feature of all the complex indels.
        """

        vread = [[] for _ in range(len(self.__vcindel))]

        # Only reads within the affected region will be associated with complex indel.
        for i, cindel in enumerate(self.__vcindel):
            brkpntl = cindel.brkpntl
            brkpntr = cindel.brkpntr
            marginl = max(brkpntl - self.__threshold, 0)
            marginr = min(brkpntr + self.__threshold, 1000000)

            for read in self.__vread:
                pos1 = read.pos
                pos2 = read.pnext
                if marginl <= pos1 and pos2 <= marginr:
                    vread[i].append(read)

        label = [0 for _ in range(len(self.__vcindel))]
        feature = [[0, 0, 0, 0] for _ in range(len(self.__vcindel))]

        # Collect features and label for each complex indel.
        for i, cindel in enumerate(self.__vcindel):
            label[i] = cindel.label
            brkpntl = cindel.brkpntl
            brkpntr = cindel.brkpntr
            marginl = max(brkpntl - self.__threshold, 0)
            marginr = min(brkpntr + self.__threshold, 1000000)

            for read in vread[i]:
                pos1 = read.pos
                pos2 = read.pnext

                # Abnormal insert size
                if self.__insertsize-3*self.__stdvar < abs(read.pos - read.pnext) < self.__insertsize+3*self.__stdvar:
                    feature[i][0] += 1

                if brkpntl < pos1 and brkpntl < pos1 + self.__readlength < brkpntr:
                    # Read depth
                    feature[i][1] += 1

                    # Fully mapped reads
                    if read.mapq == 60 and read.mate.mapq == 60:
                        feature[i][2] += 1

                # Incomplete mapped reads
                if (brkpntl < pos1 < brkpntr < pos1 + self.__readlength or
                        pos1 < brkpntl < pos1 + self.__readlength < brkpntr < pos2) and read.mate.mapq == 60:
                    feature[i][3] += 1
                if (pos2 < brkpntl < pos2 + self.__readlength < brkpntr or
                        pos1 < brkpntl < pos2 < brkpntr < pos2 + self.__readlength) and read.mapq == 60:
                    feature[i][3] += 1

                # TODO(heyongzhang@outlook.com):Affected reads

            # ReadDepth is affected significantly by the region length, so calculate the density instead.
            feature[i][1] = int(feature[i][1] / (marginr - marginl) * 10000)

        return [label, feature]
